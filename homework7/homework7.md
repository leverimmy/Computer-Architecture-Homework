# 第 7 次作业

## 第 1 题（教材 6.4）

> 指出下面这段 C 代码中的所有数据相关，对于真数据相关，还应指明它们是不是循环携带相关。试分析能否从这段循环中开发出循环级并行，并说明原因。
>
> ```c
> for(i=2;i<100;i=i+1) {
>     a[i]=b[i]+a[i];         /* S1 */
>     c[i-1]=a[i]+d[i];       /* S2 */
>     a[i-1]=2 * b[i];        /* S3 */
>     b[i+1]=2 * b[i];        /* S4 */
> }
> ```

1. S1 中的写 `a[i]` 和 S2 中的读 `a[i]` 导致 S2 与 S1 真数据相关，不是循环携带相关。
2. S3 中的写 `a[i-1]` 和 S1 中的读 `a[i]` 导致 S1 与 S3 真数据相关，是循环携带相关。
3. S4 中的写 `b[i+1]` 和 S1 中的读 `b[i]` 导致 S1 与 S4 真数据相关，是循环携带相关。
4. S4 中的写 `b[i+1]` 和 S3 中的读 `b[i]` 导致 S3 与 S4 真数据相关，是循环携带相关。
5. S4 中的写 `b[i+1]` 和 S4 中的读 `b[i]` 导致 S4 与 S4 真数据相关，是循环携带相关。
6. S3 中的写 `a[i-1]` 和 S1 中的写 `a[i]` 导致 S1 和 S3 输出相关，是循环携带相关。

由于存在相关距离为 $1$ 的循环携带相关，所以无法直接从这段循环中开发出循环级并行。

## 第 2 题（教材 6.5）

> 下面的循环中含有相关距离为 $1$ 的循环携带相关，无法从中开发出大量的循环级并行。像例 6.8 那样对这段代码进行调整，使得多个循环迭代可以并行执行。
>
> ```c
> for(i=1;i<100;i=i+1) {
>     a[i]=b[i]+c[i];         /* S1 */
>     b[i]=a[i]+d[i];         /* S2 */
>     a[i+1]=a[i]+e[i];       /* S3 */
> }
> ```

调整后的代码如下：

```c
a[1]=b[1]+c[1];
a[2]=a[1]+e[1];
for(i=1;i<99;i=i+1) {
    b[i]=a[i]+d[i];
    a[i+1]=b[i+1]+d[i+1];
    a[i+2]=a[i+1]+e[i+1];
}
b[99]=a[99]+d[99];
```

可以看出，调整后的代码中不存在循环携带相关，因此使得多个循环迭代可以并行执行。

## 第 3 题（教材 6.6）

> 假设某超标量流水线能够同时执行一条浮点指令和一条整数指令，当下面的循环程序段在该流水线上执行时，至少应被展开多少次才能消除所有的“空转”周期。假设各指令的延迟如下表所示。
>
> | 产生结果的指令| 使用结果的指令| 延迟（时钟周期数） |
> |:-:|:-:|:-:|
> | 浮点计算 | 另一个浮点计算 | $3$ |
> | 浮点计算 | 浮点 store（`S.D`） | $2$ |
> | 浮点 load（`L.D`） | 浮点计算 | $1$ |
> | 浮点 load（`L.D`） | 浮点 store（`S.D`） | $0$ |
>
> ```assembly
> Loop: L.D       F0,0(R1)    // 取一个数组元素放入 F0
>       ADD.D     F4,F0,F2    // 加上在 F2 中的标量
>       S.D       F4,0(R1)    // 存结果
>       DADDIU    R1,R1,#-8   // 将指针减少 8（每个数据占 8 字节）
>       BNE       R1,R2,Loop  // 若 R1 不等于 R2，表示尚未结束，转移到 Loop 继续
> ```

最少展开 $4$ 次（得到 $5$ 个循环体）即可消除所有的“空转”周期。调度后的代码如下：

| | 整数指令 | 浮点指令 |
|:-:|:-|:-|
| 1 | `Loop: L.D F0,0(R1)` | |
| 2 | `L.D F6,-8(R1)` | |
| 3 | `L.D F10,-16(R1)` | `ADD.D F4,F0,F2` |
| 4 | `L.D F14,-24(R1)` | `ADD.D F8,F6,F2` |
| 5 | `L.D F18,-32(R1)` | `ADD.D F12,F10,F2` |
| 6 | `S.D F4,0(R1)` | `ADD.D F16,F14,F2` |
| 7 | `S.D F8,-8(R1)` | `ADD.D F20,F18,F2` |
| 8 | `S.D F12,-16(R1)` | |
| 9 | `DADDIU R1,R1,#-40` | |
| 10 | `S.D F16,-24(R1)` | |
| 11 | `BNE R1,R2,Loop` | |
| 12 | `S.D F20,8(R1)` | |

## 第 4 题（教材 6.8）

> 下面这段循环完成点积（Dot Product）运算，寄存器 `F2` 的初值为 $0$。试结合使用循环展开和基本指令调度技术，消除其中的所有流水线“空转”周期。假设流水线延迟如上题中的表所示，分支指令也会带来一个“空转”周期。
>
> ```assembly
> loop: L.D       F0,0(R1)
>       L.D       F4,0(R2)
>       MUL.D     F0,F0,F4
>       ADD.D     F2,F0,F2
>       DADDUI    R1,R1,#-8
>       DADDUI    R2,R2,#-8
>       BNE       R1,R3,loop
> ```

程序实际执行情况如下：

```assembly
loop: L.D       F0,0(R1)
      L.D       F4,0(R2)
      （空转）
      MUL.D     F0,F0,F4
      （空转）
      （空转）
      （空转）
      ADD.D     F2,F0,F2
      DADDUI    R1,R1,#-8
      DADDUI    R2,R2,#-8
      BNE       R1,R3,loop
      （空转）
```

展开 $2$ 次并使用指令调度技术后，得到调度后的代码如下：

```assembly
loop: L.D       F0,0(R1)
      L.D       F4,0(R2)
      L.D       F6,8(R1)
      MUL.D     F0,F0,F4
      L.D       F8,8(R2)
      L.D       F10,16(R1)
      MUL.D     F6,F6,F8
      ADD.D     F2,F0,F2
      L.D       F12,16(R2)
      DADDUI    R1,R1,#-24
      MUL.D     F10,F10,F12
      ADD.D     F2,F6,F2
      DADDUI    R2,R2,#-24
      BNE       R1,R3,loop
      ADD.D     F2,F10,F2
```

<!-- 
感觉这题有点问题——没有办法保证无“空转”周期。我最后是直接抄的网上的答案。这里倒数第 2 个 ADD.D 和最后一个 ADD.D 之间的 RAW 还是会有 1 个“空转”周期。
-->
